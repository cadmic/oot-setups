#include "actor.hpp"
#include "animation.hpp"
#include "animation_data.hpp"
#include "camera.hpp"
#include "camera_angles.hpp"
#include "collision_data.hpp"
#include "collider.hpp"
#include "search.hpp"
#include "sys_math.hpp"
#include "sys_matrix.hpp"
#include "view.hpp"

Limb gHorseIngoSkel[] = {
    { { 0, 4820, -1965 }, 0x01, LIMB_DONE },
    { { 0, 505, -1338 }, 0x02, 0x05 },
    { { 0, 0, 0 }, 0x03, LIMB_DONE },
    { { 1217, 0, 0 }, 0x04, LIMB_DONE },
    { { 2387, 0, 0 }, LIMB_DONE, LIMB_DONE },
    { { -3, 171, 1984 }, LIMB_DONE, 0x06 },
    { { 0, 68, 710 }, 0x07, 0x1F },
    { { 0, 0, 0 }, 0x08, LIMB_DONE },
    { { 1681, 0, 0 }, 0x09, 0x1E },
    { { 2122, 0, 0 }, 0x0A, 0x0E },
    { { 1406, 0, 0 }, 0x0B, LIMB_DONE },
    { { 1304, 0, 0 }, 0x0C, LIMB_DONE },
    { { 1781, 0, 0 }, LIMB_DONE, 0x0D },
    { { 0, 0, 0 }, LIMB_DONE, LIMB_DONE },
    { { 1338, 341, 756 }, 0x0F, 0x16 },
    { { 0, 0, 0 }, 0x10, LIMB_DONE },
    { { 605, 0, 0 }, 0x11, LIMB_DONE },
    { { 2419, 0, 0 }, 0x12, LIMB_DONE },
    { { 1459, 0, 0 }, 0x13, 0x15 },
    { { 660, 0, 0 }, LIMB_DONE, 0x14 },
    { { 0, 1, 0 }, LIMB_DONE, LIMB_DONE },
    { { 0, 0, 0 }, LIMB_DONE, LIMB_DONE },
    { { 1338, 341, -756 }, 0x17, LIMB_DONE },
    { { 0, 0, 0 }, 0x18, LIMB_DONE },
    { { 605, 0, 0 }, 0x19, LIMB_DONE },
    { { 2419, 0, 0 }, 0x1A, LIMB_DONE },
    { { 1459, 0, 0 }, 0x1B, 0x1D },
    { { 660, 0, 0 }, LIMB_DONE, 0x1C },
    { { 0, 0, 0 }, LIMB_DONE, LIMB_DONE },
    { { 0, 0, 0 }, LIMB_DONE, LIMB_DONE },
    { { 0, 0, 0 }, LIMB_DONE, LIMB_DONE },
    { { 655, -151, -593 }, 0x20, 0x27 },
    { { 0, 0, 0 }, 0x21, LIMB_DONE },
    { { 1123, 0, 0 }, 0x22, LIMB_DONE },
    { { 2330, 0, 0 }, 0x23, LIMB_DONE },
    { { 1573, 0, 0 }, 0x24, 0x26 },
    { { 598, 0, 0 }, LIMB_DONE, 0x25 },
    { { 0, 0, 0 }, LIMB_DONE, LIMB_DONE },
    { { 0, 0, 0 }, LIMB_DONE, LIMB_DONE },
    { { -655, -151, -593 }, 0x28, LIMB_DONE },
    { { 0, 0, 0 }, 0x29, LIMB_DONE },
    { { 1123, 0, 0 }, 0x2A, LIMB_DONE },
    { { 2330, 0, 0 }, 0x2B, LIMB_DONE },
    { { 1573, 0, 0 }, 0x2C, 0x2E },
    { { 598, 0, 0 }, LIMB_DONE, 0x2D },
    { { 0, 0, 0 }, LIMB_DONE, LIMB_DONE },
    { { 0, 0, 0 }, LIMB_DONE, LIMB_DONE },
};

u16 sHorseIngoIdleAnimFrameData[] = {
    0x0000, 0x12D4, 0xF853, 0x4000, 0x8507, 0xEEE2, 0x8C17, 0x9348, 0x0004, 0x0BD1, 0xD20E, 0xD221, 0xD259, 0xD2B3, 
    0xD32C, 0xD3BF, 0xD46A, 0xD52A, 0xD5FC, 0xD6DB, 0xD7C6, 0xD8B8, 0xD9AF, 0xDAA7, 0xDB9D, 0xDC8E, 0xDD76, 0xDE96, 
    0xE018, 0xE1D8, 0xE3B2, 0xE583, 0xE725, 0xE877, 0xE953, 0xE996, 0xE91C, 0xE63A, 0xE087, 0xD9C4, 0xD3B3, 0xD015, 
    0xCF90, 0xD0F8, 0xD354, 0xD5AE, 0xD70D, 0xD788, 0xD7DE, 0xD815, 0xD832, 0xD839, 0xD830, 0xD81A, 0xD7FE, 0xD7E0, 
    0xD7C0, 0xD79D, 0xD776, 0xD74C, 0xD71F, 0xD6EF, 0xD6BC, 0xD688, 0xD652, 0xD61A, 0xD5E1, 0xD5A7, 0xD56D, 0xD532, 
    0xD4F7, 0xD4BC, 0xD482, 0xD448, 0xD410, 0xD3D9, 0xD3A4, 0xD371, 0xD340, 0xD311, 0xD2E6, 0xD2BD, 0xD298, 0xD277, 
    0xD25A, 0xD241, 0xD22C, 0xD21D, 0xD213, 0xD20E, 0xEF9D, 0xEF91, 0xEF6E, 0xEF35, 0xEEE8, 0xEE86, 0xEE11, 0xED89, 
    0xECF1, 0xEC49, 0xEB91, 0xEACC, 0xE9F9, 0xE91A, 0xE830, 0xE73C, 0xE63E, 0xE4BB, 0xE268, 0xDF8F, 0xDC7A, 0xD975, 
    0xD6C9, 0xD4C1, 0xD3A8, 0xD3C8, 0xD56B, 0xDC80, 0xE9D8, 0xF910, 0x05C6, 0x0B98, 0x07C0, 0xFD2B, 0xF001, 0xE468, 
    0xDE88, 0xDDF9, 0xDF3E, 0xE1E1, 0xE56F, 0xE970, 0xED6F, 0xF0F8, 0xF395, 0xF4CF, 0xF4B6, 0xF3C7, 0xF235, 0xF032, 
    0xEDF1, 0xEBA2, 0xE979, 0xE7A8, 0xE661, 0xE5D6, 0xE645, 0xE799, 0xE98B, 0xEBD5, 0xEE2F, 0xF053, 0xF1F9, 0xF2DA, 
    0xF32B, 0xF356, 0xF35E, 0xF347, 0xF318, 0xF2D3, 0xF27F, 0xF21E, 0xF1B7, 0xF14D, 0xF0E5, 0xF084, 0xF02E, 0xEFE8, 
    0xEFB7, 0xEF9F, 0x0000, 0x000C, 0x002D, 0x0062, 0x00A6, 0x00F8, 0x0153, 0x01B6, 0x021D, 0x0286, 0x02ED, 0x0350, 
    0x03AB, 0x03FD, 0x0441, 0x0476, 0x0497, 0x04A3, 0x049C, 0x0486, 0x0464, 0x0436, 0x03FE, 0x03BC, 0x0373, 0x0324, 
    0x02CF, 0x0276, 0x021A, 0x01BD, 0x0160, 0x0103, 0x00A9, 0x0052, 0x0000, 0xFFAD, 0xFF52, 0xFEF0, 0xFE89, 0xFE1D, 
    0xFDAE, 0xFD3D, 0xFCCA, 0xFC57, 0xFBE5, 0xFB74, 0xFB07, 0xFA9E, 0xFA39, 0xF9DB, 0xF984, 0xF935, 0xF8EF, 0xF8B4, 
    0xF884, 0xF860, 0xF84A, 0xF842, 0xF84E, 0xF86F, 0xF8A4, 0xF8EA, 0xF940, 0xF9A2, 0xFA10, 0xFA87, 0xFB04, 0xFB86, 
    0xFC0B, 0xFC90, 0xFD13, 0xFD92, 0xFE0B, 0xFE7C, 0xFEE3, 0xFF3D, 0xFF89, 0xFFC3, 0xFFEC, 0xFFFF, 0xE3D2, 0xE3EF, 
    0xE446, 0xE4D0, 0xE589, 0xE66C, 0xE775, 0xE89E, 0xE9E3, 0xEB3F, 0xECAE, 0xEE2B, 0xEFB0, 0xF139, 0xF2C1, 0xF445, 
    0xF5BD, 0xF727, 0xF89C, 0xFA36, 0xFBED, 0xFDBC, 0xFF9D, 0x018A, 0x037B, 0x056B, 0x0755, 0x0930, 0x0AF8, 0x0CA6, 
    0x0E34, 0x0F9B, 0x10D6, 0x11DE, 0x12AC, 0x1359, 0x13FC, 0x1496, 0x1525, 0x15A9, 0x1620, 0x1689, 0x16E4, 0x172F, 
    0x1769, 0x1792, 0x17A8, 0x17AB, 0x1798, 0x1770, 0x1732, 0x16DC, 0x166D, 0x15E4, 0x1541, 0x1482, 0x13A6, 0x12AC, 
    0x1175, 0x0FE7, 0x0E0B, 0x0BEB, 0x0991, 0x0708, 0x0458, 0x018B, 0xFEAB, 0xFBC1, 0xF8D9, 0xF5FA, 0xF330, 0xF083, 
    0xEDFD, 0xEBA9, 0xE990, 0xE7BB, 0xE634, 0xE506, 0xE439, 0xE3D8, 0x0000, 0x0016, 0x0056, 0x00BA, 0x013C, 0x01D6, 
    0x0284, 0x0340, 0x0403, 0x04CA, 0x058E, 0x064A, 0x06F7, 0x0792, 0x0814, 0x0877, 0x08B7, 0x08CE, 0x08C1, 0x089B, 
    0x085F, 0x080F, 0x07AB, 0x0737, 0x06B3, 0x0623, 0x0588, 0x04E3, 0x0437, 0x0385, 0x02D0, 0x021A, 0x0164, 0x00B0, 
    0x0000, 0xFF02, 0xFD97, 0xFC0F, 0xFABC, 0xF9EE, 0xF97D, 0xF90F, 0xF8A3, 0xF83C, 0xF7D9, 0xF77B, 0xF723, 0xF6D2, 
    0xF689, 0xF649, 0xF611, 0xF5E4, 0xF5C1, 0xF5AA, 0xF59F, 0xF5A1, 0xF5B1, 0xF5D0, 0xF603, 0xF64B, 0xF6A8, 0xF715, 
    0xF792, 0xF81B, 0xF8AF, 0xF94B, 0xF9ED, 0xFA92, 0xFB38, 0xFBDD, 0xFC7E, 0xFD19, 0xFDAB, 0xFE33, 0xFEAE, 0xFF19, 
    0xFF73, 0xFFB9, 0xFFE8, 0xFFFE, 0xF15D, 0xF162, 0xF173, 0xF18D, 0xF1B0, 0xF1DB, 0xF20E, 0xF248, 0xF287, 0xF2CC, 
    0xF315, 0xF361, 0xF3B0, 0xF401, 0xF454, 0xF4A6, 0xF4F8, 0xF549, 0xF59C, 0xF5F4, 0xF652, 0xF6B4, 0xF71A, 0xF783, 
    0xF7EE, 0xF85B, 0xF8C8, 0xF935, 0xF9A1, 0xFA0D, 0xFA75, 0xFADB, 0xFB3E, 0xFB9C, 0xFBF5, 0xFC3F, 0xFC74, 0xFC96, 
    0xFCA9, 0xFCAE, 0xFCB1, 0xFCB6, 0xFCBF, 0xFCC9, 0xFCD3, 0xFCDE, 0xFCE8, 0xFCEF, 0xFCF3, 0xFCF3, 0xFCEF, 0xFCE4, 
    0xFCD3, 0xFCBA, 0xFC98, 0xFC6C, 0xFC36, 0xFBF5, 0xFBA3, 0xFB40, 0xFACD, 0xFA4D, 0xF9C1, 0xF92C, 0xF88F, 0xF7ED, 
    0xF748, 0xF6A1, 0xF5FC, 0xF559, 0xF4BB, 0xF424, 0xF396, 0xF313, 0xF29D, 0xF237, 0xF1E2, 0xF1A0, 0xF173, 0xF15E, 
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0001, 0x0001, 0x0001, 0x0001, 0x0002, 0x0002, 0x0002, 0x0002, 
    0x0002, 0x0002, 0x0002, 0x0002, 0x0002, 0x0003, 0x0003, 0x0003, 0x0003, 0x0003, 0x0003, 0x0003, 0x0003, 0x0003, 
    0x0003, 0x0003, 0x0003, 0x0002, 0x0002, 0x0001, 0x0000, 0xFFFB, 0xFFF1, 0xFFE5, 0xFFD9, 0xFFD0, 0xFFCE, 0xFFD5, 
    0xFFE8, 0x0012, 0x0054, 0x00A3, 0x00F4, 0x013D, 0x0171, 0x0186, 0x0178, 0x0150, 0x0115, 0x00D1, 0x008C, 0x004C, 
    0x001B, 0x0000, 0xFFF4, 0xFFEB, 0xFFE3, 0xFFDD, 0xFFD9, 0xFFD7, 0xFFD6, 0xFFD6, 0xFFD7, 0xFFD9, 0xFFDC, 0xFFDF, 
    0xFFE3, 0xFFE7, 0xFFEB, 0xFFEF, 0xFFF4, 0xFFF7, 0xFFFB, 0xFFFD, 0xFFFF, 0x0000, 0x0000, 0x0010, 0x003E, 0x0086, 
    0x00E3, 0x0152, 0x01CF, 0x0256, 0x02E3, 0x0371, 0x03FE, 0x0485, 0x0502, 0x0571, 0x05CF, 0x0616, 0x0644, 0x0654, 
    0x0649, 0x0628, 0x05F5, 0x05B0, 0x055D, 0x04FD, 0x0492, 0x041F, 0x03A6, 0x0329, 0x02AA, 0x022B, 0x01AF, 0x0137, 
    0x00C6, 0x005D, 0x0000, 0xFFB0, 0xFF6C, 0xFF30, 0xFEF6, 0xFEBA, 0xFE78, 0xFE2C, 0xFDD0, 0xFD59, 0xFCC7, 0xFC26, 
    0xFB84, 0xFAED, 0xFA6E, 0xFA14, 0xF9DA, 0xF9AF, 0xF993, 0xF987, 0xF989, 0xF99A, 0xF9B8, 0xF9E3, 0xFA1A, 0xFA5A, 
    0xFAA1, 0xFAEF, 0xFB42, 0xFB9A, 0xFBF5, 0xFC52, 0xFCB1, 0xFD10, 0xFD6E, 0xFDC9, 0xFE22, 0xFE76, 0xFEC5, 0xFF0E, 
    0xFF4F, 0xFF88, 0xFFB7, 0xFFDB, 0xFFF4, 0xFFFF, 0x4274, 0x4277, 0x4280, 0x428E, 0x42A1, 0x42BA, 0x42D6, 0x42F7, 
    0x431C, 0x4345, 0x4370, 0x439F, 0x43D0, 0x4404, 0x443A, 0x4471, 0x44AA, 0x44E4, 0x451F, 0x455B, 0x459A, 0x45DA, 
    0x461C, 0x4661, 0x46A9, 0x46F3, 0x4741, 0x4791, 0x47E5, 0x483D, 0x4899, 0x48F8, 0x495C, 0x49C5, 0x4A32, 0x4AD8, 
    0x4BD1, 0x4CF4, 0x4E1C, 0x4F20, 0x4FD8, 0x501D, 0x4FC8, 0x4E71, 0x4C15, 0x4921, 0x4602, 0x4325, 0x40F7, 0x3FE6, 
    0x400C, 0x410E, 0x42A9, 0x4497, 0x4693, 0x485A, 0x49A5, 0x4A32, 0x4A3A, 0x4A29, 0x4A01, 0x49C4, 0x4975, 0x4917, 
    0x48AB, 0x4834, 0x47B5, 0x472F, 0x46A6, 0x461C, 0x4592, 0x450C, 0x448C, 0x4414, 0x43A6, 0x4346, 0x42F4, 0x42B5, 
    0x428A, 0x4275, 0x365A, 0x3653, 0x364C, 0x3645, 0x363E, 0x3637, 0x3630, 0x3629, 0x3622, 0x361B, 0x3614, 0x360D, 
    0x3606, 0x35FF, 0x35F8, 0x35F2, 0x35F7, 0x35FD, 0x3602, 0x3607, 0x360D, 0x3612, 0x3618, 0x361D, 0x3623, 0x3628, 
    0x362E, 0x3633, 0x3639, 0x363E, 0x3644, 0x3649, 0x364F, 0x3654, 0x365A, 0x365A, 0x365A, 0x365A, 0x365A, 0x365A, 
    0x365A, 0x365A, 0x365B, 0x365B, 0x365B, 0x365B, 0x365B, 0x365B, 0x365B, 0x365B, 0x365B, 0x365B, 0x365B, 0x365C, 
    0x365C, 0x365C, 0x365C, 0x365C, 0x365C, 0x365C, 0x365C, 0x365C, 0x35E2, 0x3509, 0x33EB, 0x32A0, 0x3142, 0x2FEB, 
    0x2EB4, 0x2DB6, 0x2D0B, 0x2CCD, 0x2D2E, 0x2E2F, 0x2F9F, 0x3149, 0x32FC, 0x3485, 0x35B2, 0x364E, 0xF658, 0xF643, 
    0xF62E, 0xF619, 0xF605, 0xF5F0, 0xF5DB, 0xF5C6, 0xF5B1, 0xF59C, 0xF587, 0xF573, 0xF55E, 0xF549, 0xF534, 0xF51F, 
    0xF530, 0xF540, 0xF550, 0xF561, 0xF571, 0xF582, 0xF592, 0xF5A3, 0xF5B3, 0xF5C4, 0xF5D4, 0xF5E5, 0xF5F5, 0xF606, 
    0xF616, 0xF627, 0xF637, 0xF648, 0xF658, 0xF658, 0xF659, 0xF659, 0xF659, 0xF659, 0xF65A, 0xF65A, 0xF65A, 0xF65A, 
    0xF65B, 0xF65B, 0xF65B, 0xF65C, 0xF65C, 0xF65C, 0xF65C, 0xF65D, 0xF65D, 0xF65D, 0xF65D, 0xF65E, 0xF65E, 0xF65E, 
    0xF65F, 0xF65F, 0xF65F, 0xF65F, 0xF7EB, 0xFAAA, 0xFE4A, 0x0279, 0x06E5, 0x0B3C, 0x0F2B, 0x1260, 0x1488, 0x1553, 
    0x1417, 0x10D4, 0x0C2C, 0x06C5, 0x0142, 0xFC47, 0xF87A, 0xF67E, 0xFFFC, 0x0018, 0x0034, 0x004F, 0x006B, 0x0087, 
    0x00A3, 0x00BF, 0x00DB, 0x00F6, 0x0112, 0x012E, 0x014A, 0x0166, 0x0181, 0x019D, 0x0187, 0x0171, 0x015B, 0x0145, 
    0x012F, 0x0119, 0x0104, 0x00EE, 0x00D8, 0x00C2, 0x00AC, 0x0096, 0x0080, 0x006A, 0x0054, 0x003E, 0x0028, 0x0012, 
    0xFFFC, 0xFFFC, 0xFFFB, 0xFFFB, 0xFFFB, 0xFFFA, 0xFFFA, 0xFFF9, 0xFFF9, 0xFFF9, 0xFFF8, 0xFFF8, 0xFFF8, 0xFFF7, 
    0xFFF7, 0xFFF7, 0xFFF6, 0xFFF6, 0xFFF5, 0xFFF5, 0xFFF5, 0xFFF4, 0xFFF4, 0xFFF4, 0xFFF3, 0xFFF3, 0xFFF3, 0xFFF2, 
    0xFF46, 0xFE15, 0xFC83, 0xFAB2, 0xF8C7, 0xF6E5, 0xF531, 0xF3CD, 0xF2DD, 0xF286, 0xF30F, 0xF47B, 0xF680, 0xF8D9, 
    0xFB3E, 0xFD68, 0xFF0F, 0xFFEC, 0x9348, 0x935A, 0x938C, 0x93DC, 0x9448, 0x94CD, 0x9569, 0x9618, 0x96D9, 0x97A8, 
    0x9884, 0x9968, 0x9A54, 0x9B44, 0x9C35, 0x9D26, 0x9E13, 0x9EF9, 0x9FD7, 0xA0AA, 0xA16F, 0xA223, 0xA2C4, 0xA35C, 
    0xA3DA, 0xA417, 0xA3EA, 0xA329, 0xA185, 0x9F19, 0x9C5A, 0x99BC, 0x97B5, 0x96B9, 0x96FC, 0x9827, 0x99DF, 0x9BC9, 
    0x9D88, 0x9EC2, 0x9F1C, 0x9ED2, 0x9E61, 0x9DCE, 0x9D1E, 0x9C55, 0x9B77, 0x9A89, 0x9990, 0x9890, 0x978E, 0x968E, 
    0x9594, 0x94A6, 0x93C8, 0x92FE, 0x924D, 0x91B9, 0x9178, 0x91A1, 0x920D, 0x9292, 0x9309, 0x9348, 0x9348, 0x9348, 
    0x9348, 0x9348, 0x9348, 0x9348, 0x9348, 0x9348, 0x9348, 0x9348, 0x9348, 0x9348, 0x9348, 0x9348, 0x9348, 0x9348, 
    0x365A, 0x35CC, 0x3441, 0x31E6, 0x2EE8, 0x2B72, 0x27B3, 0x23D7, 0x200B, 0x1C7D, 0x1957, 0x16C9, 0x14A0, 0x128E, 
    0x1097, 0x0EBD, 0x0D03, 0x0B6C, 0x09FA, 0x08B0, 0x0791, 0x069F, 0x05DE, 0x0557, 0x0554, 0x0639, 0x0867, 0x0C42, 
    0x130E, 0x1C9D, 0x2727, 0x30E7, 0x3814, 0x3AE9, 0x3887, 0x3242, 0x2999, 0x200C, 0x171C, 0x1048, 0x0D10, 0x0C64, 
    0x0C2E, 0x0C63, 0x0CF9, 0x0DE7, 0x0F21, 0x109E, 0x1252, 0x1435, 0x163C, 0x185B, 0x1A8B, 0x1CBE, 0x1EED, 0x210C, 
    0x2311, 0x24F2, 0x2760, 0x2AB5, 0x2E69, 0x31F2, 0x34C5, 0x365A, 0x365A, 0x365A, 0x365A, 0x365A, 0x365A, 0x365A, 
    0x365A, 0x365A, 0x365A, 0x365A, 0x365A, 0x365A, 0x365A, 0x365A, 0x365A, 0x365A, 0xF658, 0xF733, 0xF997, 0xFD42, 
    0x01F0, 0x0760, 0x0D4F, 0x137A, 0x199E, 0x1F79, 0x24C8, 0x2948, 0x2CB8, 0x2F75, 0x31FE, 0x343B, 0x3616, 0x3779, 
    0x384D, 0x387B, 0x37EE, 0x368F, 0x3446, 0x2DE9, 0x228B, 0x1574, 0x09EA, 0x0338, 0x0167, 0x01F8, 0x0461, 0x0815, 
    0x0C8C, 0x1139, 0x170B, 0x1EAE, 0x272E, 0x2F9D, 0x3707, 0x3C7E, 0x3F0F, 0x3FAF, 0x3FF4, 0x3FE4, 0x3F81, 0x3ED0, 
    0x3DD6, 0x3C95, 0x3B13, 0x3953, 0x375A, 0x352A, 0x32C9, 0x303B, 0x2D83, 0x2AA6, 0x27A7, 0x248B, 0x1F36, 0x16AD, 
    0x0CA0, 0x02C1, 0xFAC3, 0xF658, 0xF658, 0xF658, 0xF658, 0xF658, 0xF658, 0xF658, 0xF658, 0xF658, 0xF658, 0xF658, 
    0xF658, 0xF658, 0xF658, 0xF658, 0xF658, 0xF658, 0xFFFC, 0x0031, 0x00CA, 0x01BF, 0x0308, 0x049C, 0x0674, 0x0887, 
    0x0ACD, 0x0D3D, 0x0FD0, 0x127E, 0x153D, 0x1807, 0x1AD2, 0x1D96, 0x204C, 0x22EB, 0x256B, 0x27C3, 0x29EC, 0x2BDD, 
    0x2D8E, 0x2EF7, 0x3010, 0x2766, 0x181D, 0x09B2, 0xFECB, 0xFA87, 0xF98C, 0xFDB8, 0x10A3, 0x23AA, 0x294C, 0x2BBB, 
    0x2C05, 0x2B3A, 0x2A2A, 0x28F7, 0x27A5, 0x2636, 0x24AE, 0x2312, 0x2165, 0x1FAA, 0x1DE6, 0x1C1C, 0x1A4F, 0x1884, 
    0x16BE, 0x1501, 0x1351, 0x11B0, 0x1024, 0x0EAF, 0x0D55, 0x0C1A, 0x0B02, 0x0A03, 0x090F, 0x0827, 0x074B, 0x067B, 
    0x05B8, 0x0500, 0x0454, 0x03B5, 0x0321, 0x029A, 0x021F, 0x01B1, 0x014F, 0x00F9, 0x00B0, 0x0073, 0x0042, 0x001F, 
    0x0007, 0xFFFD, 0x9C2E, 0x9C25, 0x9C0B, 0x9BE2, 0x9BAC, 0x9B6B, 0x9B21, 0x9ACF, 0x9A78, 0x9A1D, 0x99C1, 0x9964, 
    0x990A, 0x98B4, 0x9863, 0x981B, 0x97CB, 0x976B, 0x9700, 0x9690, 0x9623, 0x95C0, 0x956C, 0x952F, 0x950F, 0x9512, 
    0x9540, 0x9676, 0x98C9, 0x9B13, 0x9C2E, 0x9C4D, 0x9C6B, 0x9C86, 0x9C9E, 0x9CB4, 0x9CC7, 0x9CD9, 0x9CE8, 0x9CF6, 
    0x9D01, 0x9D0A, 0x9D12, 0x9D18, 0x9D1C, 0x9D1F, 0x9D20, 0x9D20, 0x9D1F, 0x9D1C, 0x9D19, 0x9D14, 0x9D0E, 0x9D07, 
    0x9D00, 0x9CF8, 0x9CEF, 0x9CE6, 0x9CDC, 0x9CD1, 0x9CC7, 0x9CBC, 0x9CB1, 0x9CA6, 0x9C9B, 0x9C90, 0x9C85, 0x9C7A, 
    0x9C70, 0x9C66, 0x9C5D, 0x9C54, 0x9C4C, 0x9C45, 0x9C3F, 0x9C39, 0x9C35, 0x9C31, 0x9C2F, 0x9C2E, 0x3DEE, 0x3DF7, 
    0x3E10, 0x3E38, 0x3E6E, 0x3EB1, 0x3EFE, 0x3F56, 0x3FB6, 0x401D, 0x4089, 0x40FB, 0x416F, 0x41E5, 0x425C, 0x42D2, 
    0x4363, 0x4423, 0x4503, 0x45F6, 0x46EC, 0x47D7, 0x48A8, 0x4952, 0x49C5, 0x49F3, 0x49CE, 0x47CF, 0x43D1, 0x3FDA, 
    0x3DEE, 0x3DB7, 0x3D85, 0x3D57, 0x3D2E, 0x3D08, 0x3CE6, 0x3CC8, 0x3CAE, 0x3C97, 0x3C84, 0x3C74, 0x3C66, 0x3C5C, 
    0x3C55, 0x3C50, 0x3C4E, 0x3C4E, 0x3C50, 0x3C55, 0x3C5B, 0x3C63, 0x3C6D, 0x3C79, 0x3C85, 0x3C93, 0x3CA3, 0x3CB3, 
    0x3CC4, 0x3CD5, 0x3CE8, 0x3CFA, 0x3D0D, 0x3D20, 0x3D33, 0x3D46, 0x3D58, 0x3D6A, 0x3D7C, 0x3D8D, 0x3D9D, 0x3DAB, 
    0x3DB9, 0x3DC6, 0x3DD1, 0x3DDA, 0x3DE2, 0x3DE8, 0x3DEC, 0x3DEE, 0xD8E3, 0xD8E3, 0xD8E2, 0xD8DF, 0xD8DB, 0xD8D5, 
    0xD8CB, 0xD8BF, 0xD8AF, 0xD89A, 0xD881, 0xD862, 0xD83E, 0xD814, 0xD7E2, 0xD7AA, 0xD759, 0xD6E6, 0xD65A, 0xD5BD, 
    0xD51A, 0xD479, 0xD3E5, 0xD366, 0xD306, 0xD2CD, 0xD2C6, 0xD3C1, 0xD5D0, 0xD7E2, 0xD8E3, 0xD8FF, 0xD919, 0xD930, 
    0xD946, 0xD959, 0xD96B, 0xD97A, 0xD988, 0xD993, 0xD99D, 0xD9A6, 0xD9AC, 0xD9B2, 0xD9B6, 0xD9B8, 0xD9B9, 0xD9B9, 
    0xD9B8, 0xD9B6, 0xD9B2, 0xD9AE, 0xD9A9, 0xD9A3, 0xD99D, 0xD995, 0xD98D, 0xD985, 0xD97C, 0xD973, 0xD96A, 0xD960, 
    0xD957, 0xD94D, 0xD943, 0xD93A, 0xD930, 0xD927, 0xD91E, 0xD915, 0xD90D, 0xD905, 0xD8FE, 0xD8F8, 0xD8F2, 0xD8ED, 
    0xD8E9, 0xD8E6, 0xD8E4, 0xD8E3, 0x0BD1, 0x0BCC, 0x0BC0, 0x0BAE, 0x0B98, 0x0B81, 0x0B69, 0x0B53, 0x0B41, 0x0B35, 
    0x0B30, 0x0B35, 0x0B46, 0x0B64, 0x0B92, 0x0BD1, 0x0C38, 0x0CD5, 0x0D9A, 0x0E7A, 0x0F67, 0x1055, 0x1135, 0x11FA, 
    0x1298, 0x1301, 0x1326, 0x1208, 0x0F8D, 0x0D0A, 0x0BD1, 0x0BAF, 0x0B90, 0x0B74, 0x0B5A, 0x0B43, 0x0B2E, 0x0B1B, 
    0x0B0B, 0x0AFD, 0x0AF1, 0x0AE7, 0x0ADF, 0x0AD9, 0x0AD4, 0x0AD1, 0x0AD0, 0x0AD0, 0x0AD1, 0x0AD4, 0x0AD8, 0x0ADD, 
    0x0AE3, 0x0AEA, 0x0AF2, 0x0AFB, 0x0B04, 0x0B0E, 0x0B18, 0x0B23, 0x0B2F, 0x0B3A, 0x0B46, 0x0B51, 0x0B5D, 0x0B69, 
    0x0B74, 0x0B7F, 0x0B8A, 0x0B95, 0x0B9E, 0x0BA8, 0x0BB0, 0x0BB8, 0x0BBF, 0x0BC5, 0x0BC9, 0x0BCD, 0x0BD0, 0x0BD1, 
    0x9D66, 0x9D61, 0x9D52, 0x9D3B, 0x9D1D, 0x9CFA, 0x9CD4, 0x9CAB, 0x9C81, 0x9C58, 0x9C31, 0x9C0E, 0x9BF1, 0x9BDA, 
    0x9BCB, 0x9BC5, 0x9BC6, 0x9BC6, 0x9BC8, 0x9BCA, 0x9BCC, 0x9BCF, 0x9BD3, 0x9BD7, 0x9BDB, 0x9BE0, 0x9BE6, 0x9BEB, 
    0x9BF1, 0x9BF8, 0x9BFF, 0x9C06, 0x9C0D, 0x9C15, 0x9C1D, 0x9C25, 0x9C2E, 0x9C36, 0x9C3F, 0x9C48, 0x9C51, 0x9C5B, 
    0x9C64, 0x9C6E, 0x9C77, 0x9C81, 0x9C8B, 0x9C94, 0x9C9E, 0x9CA8, 0x9CB1, 0x9CBB, 0x9CC5, 0x9CCE, 0x9CD7, 0x9CE1, 
    0x9CEA, 0x9CF3, 0x9CFB, 0x9D04, 0x9D0C, 0x9D14, 0x9D1C, 0x9D23, 0x9D2B, 0x9D32, 0x9D38, 0x9D3E, 0x9D44, 0x9D4A, 
    0x9D4F, 0x9D53, 0x9D57, 0x9D5B, 0x9D5E, 0x9D61, 0x9D63, 0x9D65, 0x9D66, 0x9D66, 0x3D86, 0x3D83, 0x3D7C, 0x3D70, 
    0x3D61, 0x3D50, 0x3D3C, 0x3D28, 0x3D13, 0x3CFF, 0x3CEB, 0x3CDA, 0x3CCB, 0x3CBF, 0x3CB8, 0x3CB5, 0x3CB5, 0x3CB6, 
    0x3CB7, 0x3CB8, 0x3CB9, 0x3CBA, 0x3CBC, 0x3CBE, 0x3CC0, 0x3CC3, 0x3CC5, 0x3CC8, 0x3CCB, 0x3CCF, 0x3CD2, 0x3CD6, 
    0x3CD9, 0x3CDD, 0x3CE1, 0x3CE5, 0x3CE9, 0x3CEE, 0x3CF2, 0x3CF7, 0x3CFB, 0x3D00, 0x3D05, 0x3D09, 0x3D0E, 0x3D13, 
    0x3D18, 0x3D1D, 0x3D22, 0x3D26, 0x3D2B, 0x3D30, 0x3D35, 0x3D3A, 0x3D3E, 0x3D43, 0x3D47, 0x3D4C, 0x3D50, 0x3D55, 
    0x3D59, 0x3D5D, 0x3D61, 0x3D64, 0x3D68, 0x3D6B, 0x3D6F, 0x3D72, 0x3D75, 0x3D77, 0x3D7A, 0x3D7C, 0x3D7E, 0x3D80, 
    0x3D82, 0x3D83, 0x3D84, 0x3D85, 0x3D86, 0x3D86, 0xD87B, 0xD885, 0xD8A3, 0xD8D1, 0xD90D, 0xD953, 0xD9A0, 0xD9F2, 
    0xDA45, 0xDA97, 0xDAE5, 0xDB2B, 0xDB66, 0xDB94, 0xDBB2, 0xDBBD, 0xDBBC, 0xDBBB, 0xDBB8, 0xDBB4, 0xDBAF, 0xDBA9, 
    0xDBA1, 0xDB99, 0xDB91, 0xDB87, 0xDB7C, 0xDB71, 0xDB65, 0xDB58, 0xDB4A, 0xDB3C, 0xDB2D, 0xDB1E, 0xDB0E, 0xDAFD, 
    0xDAEC, 0xDADB, 0xDAC9, 0xDAB7, 0xDAA5, 0xDA92, 0xDA7F, 0xDA6C, 0xDA59, 0xDA46, 0xDA32, 0xDA1F, 0xDA0C, 0xD9F8, 
    0xD9E5, 0xD9D2, 0xD9BE, 0xD9AC, 0xD999, 0xD986, 0xD974, 0xD962, 0xD951, 0xD940, 0xD92F, 0xD91F, 0xD910, 0xD901, 
    0xD8F2, 0xD8E4, 0xD8D7, 0xD8CB, 0xD8BF, 0xD8B4, 0xD8AA, 0xD8A1, 0xD899, 0xD891, 0xD88B, 0xD885, 0xD881, 0xD87E, 
    0xD87C, 0xD87B, 
};

JointIndex sHorseIngoIdleAnimJointIndices[] = {
    { 0x0000, 0x0001, 0x0002 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0003, 0x0000 },
    { 0x0000, 0x0000, 0x000A },
    { 0x0000, 0x0000, 0x005A },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0003, 0x0000 },
    { 0x0000, 0x0000, 0x0004 },
    { 0x0000, 0x0000, 0x0005 },
    { 0x0000, 0x00AA, 0x00FA },
    { 0x0000, 0x014A, 0x019A },
    { 0x01EA, 0x023A, 0x028A },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0006 },
    { 0x0000, 0x0000, 0x0007 },
    { 0x0000, 0x0000, 0x02DA },
    { 0x0000, 0x0000, 0x032A },
    { 0x0000, 0x0000, 0x037A },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0008 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0006 },
    { 0x0000, 0x0000, 0x03CA },
    { 0x0000, 0x0000, 0x041A },
    { 0x0000, 0x0000, 0x046A },
    { 0x0000, 0x0000, 0x04BA },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0003, 0x0000 },
    { 0x0000, 0x0000, 0x050A },
    { 0x0000, 0x0000, 0x055A },
    { 0x0000, 0x0000, 0x05AA },
    { 0x0000, 0x0000, 0x05FA },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0003, 0x0000 },
    { 0x0000, 0x0000, 0x064A },
    { 0x0000, 0x0000, 0x069A },
    { 0x0000, 0x0000, 0x06EA },
    { 0x0000, 0x0000, 0x0009 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
};

AnimationHeader gHorseIngoIdleAnim = {
    80, sHorseIngoIdleAnimFrameData, sHorseIngoIdleAnimJointIndices, 10
};

u16 sHorseIngoRearingAnimFrameData[] = {
    0x0000, 0x4000, 0x8C17, 0x0004, 0x0000, 0x0029, 0x004C, 0xFFE6, 0xFE77, 0xFB70, 0xF73B, 0xF2C6, 0xEF01, 0xECDA, 
    0xEBE4, 0xEB16, 0xEA71, 0xE9F6, 0xE9A8, 0xE988, 0xE997, 0xE9D6, 0xEA48, 0xEAEE, 0xEBC8, 0xECDA, 0xEEBF, 0xF1CC, 
    0xF590, 0xF99F, 0xFD89, 0x00E0, 0x0336, 0x03C8, 0x02C8, 0x0138, 0x001A, 0x12F0, 0x12DB, 0x12A9, 0x126C, 0x1237, 
    0x120F, 0x11EC, 0x11C6, 0x11A2, 0x118E, 0x1188, 0x1183, 0x117F, 0x117C, 0x117A, 0x1178, 0x1178, 0x117A, 0x117C, 
    0x117F, 0x1184, 0x118A, 0x119A, 0x11B6, 0x11D9, 0x11FC, 0x1220, 0x1249, 0x126E, 0x128C, 0x12A7, 0x12CD, 0x12ED, 
    0xF853, 0xF85C, 0xF86E, 0xF882, 0xF88E, 0xF882, 0xF873, 0xF876, 0xF87E, 0xF882, 0xF880, 0xF87E, 0xF87A, 0xF876, 
    0xF872, 0xF86D, 0xF869, 0xF866, 0xF863, 0xF862, 0xF861, 0xF863, 0xF86F, 0xF886, 0xF89D, 0xF8A6, 0xF894, 0xF872, 
    0xF853, 0xF841, 0xF839, 0xF843, 0xF852, 0xD20E, 0xD360, 0xD6EC, 0xDC11, 0xE22C, 0xE89E, 0xEEC5, 0xF3FF, 0xF7AC, 
    0xF92B, 0xF8C9, 0xF75F, 0xF519, 0xF221, 0xEEA4, 0xEACF, 0xE6CD, 0xE2C9, 0xDEF1, 0xDB6F, 0xD871, 0xD621, 0xD585, 
    0xD6B2, 0xD86E, 0xD97C, 0xD8A3, 0xCF5D, 0xC6A5, 0xC7CF, 0xCBCD, 0xD011, 0xD20E, 0xEF9D, 0xF017, 0xF16C, 0xF373, 
    0xF607, 0xF8FF, 0xFC35, 0xFF81, 0x02BC, 0x05BF, 0x0863, 0x0A80, 0x0BEF, 0x0C8A, 0x0BBF, 0x0959, 0x05B7, 0x0139, 
    0xFC3F, 0xF728, 0xF254, 0xEAA2, 0xE1A7, 0xDEC9, 0xE454, 0xEDD8, 0xF8AD, 0x022B, 0x07A7, 0xFE75, 0xF0F6, 0xEEC2, 
    0xEF9D, 0x8507, 0x8507, 0x8507, 0x8507, 0x8507, 0x8507, 0x8507, 0x8507, 0x8507, 0x8507, 0x8509, 0x850D, 0x8514, 
    0x851B, 0x8522, 0x8528, 0x852D, 0x852E, 0x852C, 0x8526, 0x851A, 0x8507, 0x84E0, 0x849E, 0x844E, 0x83FA, 0x83B0, 
    0x837B, 0x8366, 0x83A6, 0x8434, 0x84C3, 0x8507, 0xEEE2, 0xEEFC, 0xEF4A, 0xEFCD, 0xF153, 0xEF46, 0xECA1, 0xE9E8, 
    0xE7A1, 0xE653, 0xE5C3, 0xE55C, 0xE51A, 0xE4F7, 0xE4F0, 0xE500, 0xE523, 0xE555, 0xE590, 0xE5D1, 0xE614, 0xE653, 
    0xE6B8, 0xE75D, 0xE827, 0xE8FE, 0xE9C9, 0xEA6C, 0xEACF, 0xE963, 0xE85D, 0xEBDB, 0xEEE2, 0xE3D2, 0xE711, 0xEE35, 
    0xF55A, 0xF899, 0xF6A2, 0xF1DF, 0xEC03, 0xE6C3, 0xE3D2, 0xE2BF, 0xE1F6, 0xE16E, 0xE122, 0xE109, 0xE11E, 0xE159, 
    0xE1B4, 0xE227, 0xE2AD, 0xE33D, 0xE3D2, 0xE4DA, 0xE697, 0xE8B7, 0xEAEA, 0xECE0, 0xEE48, 0xEED2, 0xED21, 0xE965, 
    0xE59F, 0xE3D2, 0xF15D, 0xF325, 0xF711, 0xFAFD, 0xFCC5, 0xFBB1, 0xF914, 0xF5DC, 0xF2FA, 0xF15D, 0xF0C7, 0xF05A, 
    0xF013, 0xEFEC, 0xEFE2, 0xEFF0, 0xF012, 0xF045, 0xF084, 0xF0CA, 0xF114, 0xF15D, 0xF1DC, 0xF2B2, 0xF3B8, 0xF4C7, 
    0xF5B9, 0xF666, 0xF6A9, 0xF5D8, 0xF40C, 0xF23B, 0xF15D, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0010, 0x0030, 
    0x0048, 0x0040, 0x0000, 0xFF69, 0xFE8A, 0xFD90, 0xFCA6, 0xFBF9, 0xFBB5, 0xFBFB, 0xFCAD, 0xFD9B, 0xFE98, 0xFF74, 
    0x0000, 0x003E, 0x0056, 0x0053, 0x003E, 0x0022, 0x000A, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x4274, 0x43CA, 
    0x46BB, 0x49AC, 0x4B02, 0x4A33, 0x483D, 0x45D4, 0x43AA, 0x4274, 0x4203, 0x41B0, 0x4179, 0x4159, 0x414F, 0x4158, 
    0x4171, 0x4196, 0x41C6, 0x41FC, 0x4237, 0x4274, 0x42B9, 0x4312, 0x4388, 0x441F, 0x44DE, 0x45CC, 0x46EF, 0x4AE9, 
    0x4DB4, 0x47D6, 0x4274, 0x9348, 0x93EC, 0x956E, 0x9730, 0x9894, 0x984B, 0x978C, 0x96B6, 0x95EC, 0x9552, 0x950D, 
    0x9507, 0x950D, 0x9513, 0x9524, 0x9532, 0x955E, 0x95B4, 0x9609, 0x9632, 0x9604, 0x9552, 0x93DC, 0x91B2, 0x8F24, 
    0x8C84, 0x8A20, 0x87C9, 0x862F, 0x881C, 0x9348, 0x9437, 0x9348, 0x0000, 0x0027, 0x0068, 0x0075, 0x0000, 0xFBED, 
    0xFC3C, 0xFD2F, 0xFE51, 0xFF2F, 0xFFC3, 0x0021, 0x0000, 0xFEEB, 0xFD57, 0xFC55, 0xFC11, 0xFBF8, 0xFC04, 0xFC2D, 
    0xFC6E, 0xFCBE, 0xFD38, 0xFDE6, 0xFEAC, 0xFF69, 0x0000, 0x0027, 0x0011, 0xFFFE, 0x0000, 0x0000, 0x0000, 0x0000, 
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFF3C, 0xFE4A, 0xFD7D, 0xFD26, 0xFDC8, 0xFF0D, 0x0000, 0x0036, 0x001B, 
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFE, 
    0x0000, 0x0000, 0x0000, 0x0000, 0x365A, 0x2FB3, 0x26A7, 0x23B7, 0x2334, 0x26D0, 0x18BD, 0x0736, 0xF73D, 0xEDD4, 
    0xF083, 0xFBE7, 0x079B, 0x1375, 0x1FA1, 0x2440, 0x1F73, 0x1644, 0x0B32, 0x00BC, 0xF95F, 0xF79B, 0xFDD6, 0x0AAC, 
    0x1AE7, 0x2B54, 0x38C0, 0x408E, 0x438C, 0x3C6E, 0x3863, 0x36DF, 0x365A, 0xF658, 0x04FE, 0x183A, 0x1C0B, 0x1B03, 
    0x16A8, 0x1F37, 0x2A3B, 0x344A, 0x39FA, 0x35E6, 0x2C13, 0x2736, 0x2DC2, 0x3945, 0x411C, 0x4415, 0x4682, 0x4805, 
    0x483E, 0x46CF, 0x4359, 0x3C74, 0x320F, 0x25D7, 0x1975, 0x0E95, 0x055C, 0x0064, 0x0B65, 0xFDAD, 0xF848, 0xF658, 
    0xFFFC, 0xF682, 0xEA15, 0xE489, 0xE85A, 0x1087, 0x1FA8, 0x2BA4, 0x3536, 0x3D1A, 0x41C3, 0x4300, 0x4396, 0x446E, 
    0x449F, 0x4433, 0x43F6, 0x443D, 0x445D, 0x43A9, 0x4177, 0x3D1A, 0x3545, 0x2A33, 0x1D84, 0x10D9, 0x05D1, 0xFEBA, 
    0xF969, 0xF376, 0xFD8A, 0xFFCC, 0xFFFC, 0x9348, 0x9423, 0x962C, 0x9898, 0x9A9E, 0x9B11, 0x9ACB, 0x9A66, 0x9A06, 
    0x99CD, 0x99C0, 0x99C6, 0x99D7, 0x99F0, 0x9A09, 0x9A1C, 0x9A34, 0x9A3F, 0x9A6A, 0x9AB5, 0x9AA9, 0x99CD, 0x97FE, 
    0x9595, 0x92D8, 0x900F, 0x8D7F, 0x8B11, 0x894E, 0x8A72, 0x9348, 0x9405, 0x9348, 0x0000, 0xFFA6, 0xFF10, 0xFEF2, 
    0x0000, 0x095F, 0x09A0, 0x08A5, 0x0703, 0x054C, 0x0239, 0x0000, 0x0108, 0x0320, 0x052F, 0x061D, 0x0320, 0x0000, 
    0x008C, 0x021B, 0x03BB, 0x047B, 0x041F, 0x0338, 0x020C, 0x00E2, 0x0000, 0xFFCA, 0xFFE9, 0x0003, 0x0000, 0x0000, 
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
    0x0001, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x365A, 0x32F0, 0x2B1C, 0x227D, 0x1CAF, 0x2669, 0x206B, 0x180C, 
    0x0F3B, 0x07E7, 0x048D, 0x02C8, 0xFED5, 0xFA12, 0xF6C6, 0xF738, 0x05A2, 0x1542, 0x1803, 0x1759, 0x1660, 0x1833, 
    0x1DB4, 0x2503, 0x2D1B, 0x34F8, 0x3B95, 0x3F26, 0x3FBA, 0x3A9A, 0x3863, 0x3706, 0x365A, 0xF658, 0xFAD2, 0x052B, 
    0x10C3, 0x18FA, 0x0F43, 0x1B13, 0x2A9F, 0x3983, 0x4359, 0x3D2F, 0x3256, 0x2FE2, 0x2EFA, 0x2EB9, 0x2E39, 0x2C6B, 
    0x2CD4, 0x332E, 0x3C1F, 0x430B, 0x4359, 0x3B5A, 0x2E45, 0x1ED9, 0x0FD6, 0x03FB, 0x0009, 0x01D5, 0x0A57, 0xFDAD, 
    0xF85F, 0xF658, 0xFFFC, 0xFCE5, 0xF663, 0xF09A, 0xEFB0, 0x0E7D, 0x1BF2, 0x277E, 0x30A9, 0x36FD, 0x3AB4, 0x3CB0, 
    0x3D7B, 0x3D9D, 0x3DA0, 0x3E0A, 0x3E34, 0x3D61, 0x3CFE, 0x3CFE, 0x3B96, 0x36FD, 0x2E62, 0x2321, 0x16B5, 0x0A99, 
    0x0049, 0xFB76, 0xF886, 0xF0DD, 0xFDF2, 0x0038, 0xFFFC, 0x0000, 0xFFD2, 0xFF64, 0xFEDB, 0xFE5F, 0xFDED, 0xFD6F, 
    0xFCEB, 0xFC6A, 0xFBF3, 0xFB8F, 0xFB45, 0xFB1C, 0xFB0A, 0xFAFE, 0xFAF7, 0xFAF5, 0xFAF8, 0xFB00, 0xFB0E, 0xFB21, 
    0xFB39, 0xFB56, 0xFB79, 0xFBA0, 0xFBCD, 0xFBFF, 0xFC36, 0xFC72, 0xFD23, 0xFE58, 0xFF7D, 0x0000, 0x0000, 0xFFEA, 
    0xFFAE, 0xFF57, 0xFEF0, 0xFE68, 0xFDBE, 0xFD11, 0xFC82, 0xFC2F, 0xFC09, 0xFBE8, 0xFBCD, 0xFBB8, 0xFBAA, 0xFBA4, 
    0xFBA6, 0xFBAF, 0xFBC1, 0xFBDD, 0xFC01, 0xFC2F, 0xFC80, 0xFD01, 0xFDA1, 0xFE4E, 0xFEF9, 0xFF8F, 0x0000, 0x0032, 
    0x002C, 0x0011, 0x0000, 0x0000, 0xFFE1, 0xFF91, 0xFF21, 0xFEA2, 0xFE04, 0xFD41, 0xFC7D, 0xFBDA, 0xFB7D, 0xFB50, 
    0xFB2A, 0xFB0A, 0xFAF2, 0xFAE2, 0xFADA, 0xFADC, 0xFAE6, 0xFAFB, 0xFB1B, 0xFB46, 0xFB7D, 0xFBDC, 0xFC75, 0xFD32, 
    0xFDFF, 0xFEC9, 0xFF7A, 0x0000, 0x003B, 0x0035, 0x0014, 0x0000, 0x9C2E, 0x9BD5, 0x9B3B, 0x9B08, 0x9BE2, 0x9E4C, 
    0xA1CA, 0xA58B, 0xA8BE, 0xAA91, 0xAB5D, 0xAC09, 0xAC92, 0xACF7, 0xAD37, 0xAD51, 0xAD45, 0xAD0F, 0xACB1, 0xAC28, 
    0xAB73, 0xAA91, 0xA8FD, 0xA673, 0xA34F, 0x9FF0, 0x9CB4, 0x99F8, 0x981B, 0x9801, 0x997D, 0x9B4C, 0x9C2E, 0x3DEE, 
    0x3E74, 0x3FCC, 0x41A5, 0x43A9, 0x4585, 0x478D, 0x49E1, 0x4BE7, 0x4D01, 0x4D6D, 0x4DCC, 0x4E1C, 0x4E5A, 0x4E84, 
    0x4E97, 0x4E91, 0x4E6E, 0x4E2D, 0x4DCB, 0x4D45, 0x4C99, 0x4B71, 0x49A1, 0x4764, 0x44F4, 0x428C, 0x4066, 0x3EBF, 
    0x3DDB, 0x3DA3, 0x3DC5, 0x3DEE, 0xD8E3, 0xD86D, 0xD72E, 0xD55A, 0xD324, 0xD0BF, 0xCE60, 0xCC3A, 0xCA80, 0xC967, 
    0xC8C0, 0xC83A, 0xC7D5, 0xC791, 0xC76C, 0xC768, 0xC782, 0xC7BC, 0xC814, 0xC88A, 0xC91E, 0xC9D0, 0xCAF6, 0xCCC4, 
    0xCEFE, 0xD16C, 0xD3D3, 0xD5FB, 0xD7AA, 0xD8A0, 0xD8F6, 0xD8F4, 0xD8E3, 0x0BD1, 0x0C0D, 0x0CB1, 0x0DA1, 0x0EC2, 
    0x0FF8, 0x1129, 0x123A, 0x1310, 0x138F, 0x13CD, 0x13F4, 0x1406, 0x1404, 0x13EF, 0x13CA, 0x1396, 0x1355, 0x1308, 
    0x12B2, 0x1253, 0x11ED, 0x115B, 0x1087, 0x0F88, 0x0E77, 0x0D6E, 0x0C83, 0x0BD1, 0x0B81, 0x0B8A, 0x0BB6, 0x0BD1, 
    0x0000, 0x000F, 0x0036, 0x0072, 0x00BC, 0x0120, 0x019E, 0x021F, 0x028A, 0x02C7, 0x02E4, 0x02FD, 0x0310, 0x031F, 
    0x0329, 0x032E, 0x032D, 0x0325, 0x0318, 0x0304, 0x02E9, 0x02C7, 0x028C, 0x022F, 0x01BA, 0x013C, 0x00C0, 0x0052, 
    0x0000, 0xFFDC, 0xFFE0, 0xFFF4, 0x0000, 0x0000, 0x002D, 0x00A2, 0x0147, 0x0204, 0x02F3, 0x0419, 0x0542, 0x0639, 
    0x06C6, 0x070A, 0x0743, 0x0773, 0x0797, 0x07AF, 0x07BB, 0x07B9, 0x07A8, 0x0789, 0x0759, 0x0719, 0x06C6, 0x0636, 
    0x0552, 0x0436, 0x0302, 0x01D3, 0x00C9, 0x0000, 0xFFA7, 0xFFB1, 0xFFE2, 0x0000, 0x9D66, 0x9CE6, 0x9BF2, 0x9B5E, 
    0x9BFF, 0x9E60, 0xA1ED, 0xA5C8, 0xA915, 0xAAF5, 0xABC6, 0xAC75, 0xAD00, 0xAD68, 0xADA9, 0xADC4, 0xADB7, 0xAD81, 
    0xAD21, 0xAC95, 0xABDC, 0xAAF5, 0xA956, 0xA6B6, 0xA379, 0xA001, 0x9CB2, 0x99EF, 0x981B, 0x983D, 0x9A23, 0x9C57, 
    0x9D66, 0x3D86, 0x3E10, 0x3F74, 0x415A, 0x436A, 0x454B, 0x474B, 0x498E, 0x4B84, 0x4C99, 0x4D0A, 0x4D6F, 0x4DC7, 
    0x4E0F, 0x4E43, 0x4E60, 0x4E65, 0x4E4D, 0x4E16, 0x4DBD, 0x4D3F, 0x4C99, 0x4B76, 0x49AB, 0x4770, 0x4501, 0x4298, 
    0x406E, 0x3EBF, 0x3DC5, 0x3D6A, 0x3D6B, 0x3D86, 0xD87B, 0xD808, 0xD6D3, 0xD50D, 0xD2E7, 0xD094, 0xCE45, 0xCC2D, 
    0xCA7D, 0xC967, 0xC8BE, 0xC833, 0xC7C5, 0xC776, 0xC745, 0xC733, 0xC741, 0xC76E, 0xC7BC, 0xC829, 0xC8B8, 0xC967, 
    0xCA94, 0xCC70, 0xCEBF, 0xD143, 0xD3BF, 0xD5F5, 0xD7AA, 0xD890, 0xD8C2, 0xD89C, 0xD87B, 0x0BD1, 0x0C0D, 0x0CAF, 
    0x0D9E, 0x0EBD, 0x0FF2, 0x1123, 0x1234, 0x130C, 0x138F, 0x13D3, 0x1403, 0x141E, 0x1427, 0x141F, 0x1406, 0x13DD, 
    0x13A7, 0x1363, 0x1314, 0x12BA, 0x1256, 0x11BF, 0x10DE, 0x0FCE, 0x0EAA, 0x0D8C, 0x0C90, 0x0BD1, 0x0B7B, 0x0B85, 
    0x0BB4, 0x0BD1, 
};

JointIndex sHorseIngoRearingAnimJointIndices[] = {
    { 0x0000, 0x0025, 0x0046 },
    { 0x0004, 0x0000, 0x0000 },
    { 0x0000, 0x0001, 0x0000 },
    { 0x0000, 0x0000, 0x0067 },
    { 0x0000, 0x0000, 0x0088 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0001, 0x0000 },
    { 0x0000, 0x0000, 0x00A9 },
    { 0x0000, 0x0000, 0x00CA },
    { 0x0000, 0x0000, 0x00EB },
    { 0x0000, 0x0000, 0x010C },
    { 0x012D, 0x0000, 0x014E },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0002 },
    { 0x0000, 0x0000, 0x016F },
    { 0x0190, 0x01B1, 0x01D2 },
    { 0x0000, 0x0000, 0x01F3 },
    { 0x0000, 0x0000, 0x0214 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0003 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0002 },
    { 0x0000, 0x0000, 0x0235 },
    { 0x0256, 0x0277, 0x0298 },
    { 0x0000, 0x0000, 0x02B9 },
    { 0x0000, 0x0000, 0x02DA },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x02FB },
    { 0x0000, 0x0001, 0x0000 },
    { 0x031C, 0x033D, 0x035E },
    { 0x0000, 0x0000, 0x037F },
    { 0x0000, 0x0000, 0x03A0 },
    { 0x0000, 0x0000, 0x03C1 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0001, 0x0000 },
    { 0x03E2, 0x0403, 0x0424 },
    { 0x0000, 0x0000, 0x0445 },
    { 0x0000, 0x0000, 0x0466 },
    { 0x0000, 0x0000, 0x0487 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
    { 0x0000, 0x0000, 0x0000 },
};

AnimationHeader gHorseIngoRearingAnim = { 
    33, sHorseIngoRearingAnimFrameData, sHorseIngoRearingAnimJointIndices, 4
};

BgCamInfo gJumpableHorseFenceColCamDataList[] = {
    { 0x0000, 0, NULL },
};

SurfaceType gJumpableHorseFenceColSurfaceType[] = {
    {0x00200000, 0x000007C0},   {0x00000000, 0x000007C0},
};

CollisionPoly gJumpableHorseFenceColPolygons[] = {
    {0x0000, 0x2000, 0x0001, 0x0002, 0x0000, 0x0000, 0x7FFF, 0xFF9C},
    {0x0000, 0x2000, 0x0002, 0x0003, 0x0000, 0x0000, 0x7FFF, 0xFF9C},
    {0x0000, 0x2004, 0x0005, 0x0006, 0x0000, 0x0000, 0x8001, 0xFF9C},
    {0x0000, 0x2004, 0x0006, 0x0007, 0x0000, 0x0000, 0x8001, 0xFF9C},
    {0x0001, 0x2002, 0x0005, 0x0004, 0x0000, 0x7FFF, 0x0000, 0xFD80},
    {0x0001, 0x2002, 0x0004, 0x0003, 0x0000, 0x7FFF, 0x0000, 0xFD80},
    {0x0000, 0x2001, 0x0006, 0x0005, 0x7FFF, 0x0000, 0x0000, 0xF9C0},
    {0x0000, 0x2001, 0x0005, 0x0002, 0x7FFF, 0x0000, 0x0000, 0xF9C0},
    {0x0000, 0x2007, 0x0000, 0x0003, 0x8001, 0x0000, 0x0000, 0xF9C0},
    {0x0000, 0x2007, 0x0003, 0x0004, 0x8001, 0x0000, 0x0000, 0xF9C0},
};

Vec3s gJumpableHorseFenceColVertices[] = {
    {  -1600,      0,    100 },
    {   1600,      0,    100 },
    {   1600,    640,    100 },
    {  -1600,    640,    100 },
    {  -1600,    640,   -100 },
    {   1600,    640,   -100 },
    {   1600,      0,   -100 },
    {  -1600,      0,   -100 },
};

CollisionHeader gJumpableHorseFenceCol = {
    { -1600, 0, -100 },
    { 1600, 800, 100 },
    ARRAY_COUNT(gJumpableHorseFenceColVertices), gJumpableHorseFenceColVertices,
    ARRAY_COUNT(gJumpableHorseFenceColPolygons), gJumpableHorseFenceColPolygons,
    gJumpableHorseFenceColSurfaceType,
    gJumpableHorseFenceColCamDataList,
    0, NULL
};

// height, yshift
std::vector<std::pair<int, int>> rollCylinders = {
    { 53, 5 },
    { 46, 12 },
    { 45, 11 },
    { 34, 6 },
    { 10, 14 },
    { 5, 19 },
    { 14, 19 },
    { 1, 21 },
    { 11, 13 },
    { 24, 6 },
    { 27, 6 },
    { 30, 5 },
    { 32, 5 },
    { 32, 5 },
    { 33, 5 },
};

bool simulateOneRoll(Vec3f pos, u16 angle, Vec3s horseBody, const std::vector<Vec3s>& horseHead,
                     int targetJumpFrame, int targetNeighFrame, int* outNeighFrame, int* outStrainDir, bool debug) {
    printf("targetJumpFrame=%d targetNeighFrame=%d\n", targetJumpFrame, targetNeighFrame);
    f32 xzSpeed = 0.0f;
    int jumpFrame = -1;
    int neighFrame = targetNeighFrame - targetJumpFrame - 1;

    for (int i = 1; i < 10; i++, neighFrame++) {
        s16 height = rollCylinders[i - 1].first;
        s16 yshift = rollCylinders[i - 1].second;
        if (debug) {
            printf("roll frame %d: angle=%04x x=%.9g y=%.9g z=%.9g xzSpeed=%.1f height=%d yshift=%d neighFrame=%d\n",
                i, angle, pos.x, pos.y, pos.z, xzSpeed, height, yshift, neighFrame);
        }

        Vec3s headPos = horseHead[neighFrame];
        Sphere16 headSph = { headPos, 20 };
        Cylinder16 linkCyl = { 12, height, yshift, pos.toVec3s() };

        Vec3f bodyPush = immovablePush(pos, Vec3f(horseBody), 20.0f);
        if (colliderSphVsCyl(&headSph, &linkCyl)) {
            bodyPush = bodyPush + immovablePush(pos, Vec3f(headPos), 20.0f);
        }
        pos = translate(pos, angle, xzSpeed, -5.0f, bodyPush);

        if (pos.x >= 284.0f && pos.x <= 306.0f && pos.z <= -828.0f) {
            pos.y = 37.0f;
        } else {
            jumpFrame = i;
            break;
        }

        xzSpeed = std::min(xzSpeed + 2.0f, 9.0f);
    }

    Vec3f jumpPos = pos;
    u16 jumpAngle = angle;
    if (jumpFrame != targetJumpFrame) {
        if (debug) {
            printf("bad jump jumpFrame=%d\n", jumpFrame);
        }
        return false;
    }

    neighFrame++;
    if (debug) {
        printf("jump frame: x=%.9g y=%.9g z=%.9g neighFrame=%d\n", pos.x, pos.y, pos.z, neighFrame);
    }

    neighFrame++;

    for (int strainDir : {-1, 1}) {
        pos = jumpPos;
        angle = jumpAngle + 0x12c * strainDir;

        Vec3f bodyPush = immovablePush(pos, Vec3f(horseBody), 20.0f);
        pos = translate(pos, angle, 6.0f, 6.5f, bodyPush);

        if (debug) {
            printf("test push: strainDir=%d x=%.9g y=%.9g z=%.9g\n", strainDir, pos.x, pos.y, pos.z);
        }

        Vec3s posTrunc = pos.toVec3s();
        Vec3s headPos = horseHead[neighFrame];
        if (posTrunc.x == headPos.x + 1 && posTrunc.z == headPos.z + 2) {
            if (debug) {
                printf("success neighFrame=%d\n", neighFrame);
            }
            *outNeighFrame = neighFrame;
            *outStrainDir = strainDir;
            return true;
        }
    }

    if (debug) {
        printf("no push\n");
    }
    return false;
}

bool simulateRoll(Vec3f pos, u16 angle, Vec3s horseBody, const std::vector<Vec3s>& horseHead, int* outNeighFrame, int* outStrainDir, bool debug) {
    Vec3f horseHeadPos = Vec3f(horseHead[0]);
    if (Math_Vec3f_DistXZ(&pos, &horseHeadPos) < 36.0f) {
        if (debug) {
            printf("too close to head\n");
        }
        return false;
    }

    Vec3f horseBodyPos = Vec3f(horseBody);
    if (Math_Vec3f_DistXZ(&pos, &horseBodyPos) < 32.0f) {
        if (debug) {
            printf("too close to body\n");
        }
        return false;
    }

    if (simulateOneRoll(pos, angle, horseBody, horseHead, 5, 27, outNeighFrame, outStrainDir, debug) ||
        simulateOneRoll(pos, angle, horseBody, horseHead, 8, 27, outNeighFrame, outStrainDir, debug) ||
        simulateOneRoll(pos, angle, horseBody, horseHead, 8, 28, outNeighFrame, outStrainDir, debug) ||
        simulateOneRoll(pos, angle, horseBody, horseHead, 9, 27, outNeighFrame, outStrainDir, debug)) {
        return true;
    } else {
        return false;
    }
}

bool testCull(Camera* camera, f32 fovy, bool debug) {
    Vec3f horseSpawn = {124, 0, -1343};
    CullZone horseZone = {1000, 1200, 300};
    Vec3f eponaSpawn = {0, 0, -500};
    CullZone eponaZone = {1000, 600, 300};

    if (!isCulled(camera, &horseZone, horseSpawn, fovy, 10.0f, 1280.0f)) {
        if (debug) {
            printf("fovy=%.1f horse not culled\n", fovy);
        }
        return false;
    }
    if (!isCulled(camera, &eponaZone, eponaSpawn, fovy, 10.0f, 1280.0f)) {
        if (debug) {
            printf("fovy=%.1f epona not culled\n", fovy);
        }
        return false;
    }

    if (debug) {
        printf("fovy=%.1f success\n", fovy);
    }
    return true;
}

bool testSetup(Collision* col, Vec3f pos, u16 angle, Vec3s horseBody, const std::vector<Vec3s>& horseHead,
               int* outNeighFrame, int* outStrainDir, bool* outNonCrit, bool debug) {
    u16 rollAngle = cameraAngles[angle] - 0x4000;
    if (!simulateRoll(pos, rollAngle, horseBody, horseHead, outNeighFrame, outStrainDir, debug)) {
        return false;
    }

    // Recheck with camera angles
    Camera camera(col);
    camera.initParallel(pos, angle, 1);

    for (int i = 0; i < 10; i++) {
        camera.updateNormal(pos, angle, 1);
    }
    for (int i = 0; i < 2; i++) {
        camera.updateNormal(pos, rollAngle, 1);
    }

    f32 xzSpeed = 0.0f;
    for (int i = 1; i < 10; i++) {
        if (debug) {
            printf("roll frame %d: camera=%04x angle=%04x x=%.9g y=%.9g z=%.9g xzSpeed=%.1f\n",
                i, camera.yaw(), rollAngle, pos.x, pos.y, pos.z, xzSpeed);
        }

        Vec3f bodyPush = immovablePush(pos, Vec3f(horseBody), 20.0f);
        pos = translate(pos, rollAngle, xzSpeed, -5.0f, bodyPush);

        if (pos.x >= 284.0f && pos.x <= 306.0f && pos.z <= -828.0f) {
            pos.y = 37.0f;
            camera.updateNormal(pos, rollAngle, 1);
        } else {
            camera.updateJump(pos, rollAngle, 1);
            break;
        }

        xzSpeed = std::min(xzSpeed + 2.0f, 9.0f);
    }

    Vec3f jumpPos = pos;
    u16 jumpAngle = rollAngle;
    if (debug) {
        printf("jump frame: camera=%04x x=%.9g y=%.9g z=%.9g\n", camera.yaw(), pos.x, pos.y, pos.z);
    }

    pos = jumpPos;
    angle = jumpAngle + 0x12c * *outStrainDir;

    Vec3f bodyPush = immovablePush(pos, Vec3f(horseBody), 20.0f);
    pos = translate(pos, angle, 6.0f, 6.5f, bodyPush);
    camera.updateJump(pos, angle, 1);

    if (debug) {
        printf("test push: camera=%04x strainDir=%d x=%.9g y=%.9g z=%.9g\n", camera.yaw(), *outStrainDir, pos.x, pos.y, pos.z);
    }

    if (testCull(&camera, 60.0f, debug)) {
        *outNonCrit = true;
        return true;
    }

    if (testCull(&camera, 48.0f, debug)) {
        *outNonCrit = false;
        return true;
    }

    return false;
}

Vec3s generateHorseBody1(Vec3f pos, u16 angle) {
    pos.y -= 11.25f;  // gravity
    Vec3s bodyPos = pos.toVec3s();

    bodyPos.x += (s16)(Math_SinS(angle) * 11.0f);
    bodyPos.z += (s16)(Math_CosS(angle) * 11.0f);

    return bodyPos;
}

Vec3s generateHorseBody2(Vec3f pos, u16 angle) {
    pos.y -= 11.25f;  // gravity
    Vec3s bodyPos = pos.toVec3s();

    bodyPos.x += (s16)(Math_SinS(angle) * -18.0f);
    bodyPos.z += (s16)(Math_CosS(angle) * -18.0f);

    return bodyPos;
}

std::vector<Vec3s> generateHorseHeads(Vec3f pos, u16 angle) {
    std::vector<Vec3s> result;

    for (int i = 0; i < 33; i++) {
        int limbCount = ARRAY_COUNT(gHorseIngoSkel);
        Vec3s jointTable[limbCount];
        MtxF limbMatrices[limbCount];
        Vec3f rootPos;

        loadAnimFrame(&gHorseIngoRearingAnim, limbCount, i, &rootPos, jointTable);
        applySkeleton(gHorseIngoSkel, jointTable, pos, angle, rootPos, limbMatrices);

        Vec3f sZeroVec = {0.0f, 0.0f, 0.0f};
        Vec3f headPos;
        SkinMatrix_Vec3fMtxFMultXYZ(&limbMatrices[13], &sZeroVec, &headPos);

        result.push_back(headPos.toVec3s());
    }

    return result;
}

void searchRolls(Collision* col) {
    PosAngleRange range = {
        .angleMin = 0x3800,
        .angleMax = 0x5800,
        .angleStep = 0x100,
        .xMin = 284,
        .xMax = 306,
        .xStep = 0.5f,
        .zMin = -870,
        .zMax = -835,
        .zStep = 0.5f,
    };

    for (u16 horseAngle = 0x4000; horseAngle <= 0xc000; horseAngle += 0x100) {
        for (f32 horseX = 245; horseX <= 365; horseX += 5) {
            for (f32 horseZ = -829; horseZ <= -769; horseZ += 5) {
                Vec3f horsePos = {horseX, 0, horseZ};
                if (col->runChecks(horsePos, translate(horsePos, horseAngle, 0, -7.5f), 19.0f, 35.0f) != horsePos) {
                    continue;
                }

                fprintf(stderr, "horse: angle=%04x x=%.9g z=%.9g\n", horseAngle, horsePos.x, horsePos.z);

                Vec3s horseBody = generateHorseBody1(horsePos, horseAngle);
                std::vector<Vec3s> horseHeads = generateHorseHeads(horsePos, horseAngle);
                s16 headX = horseHeads[27].x;
                s16 headZ = horseHeads[27].z;

                searchPosAngleRange(range, [&](u16 angle, f32 x, f32 z) {
                    bool found = false;

                    Vec3f pos = {x, 37, z};
                    int neighFrame;
                    int strainDir;
                    bool nonCrit;
                    if (testSetup(col, pos, angle, horseBody, horseHeads, &neighFrame, &strainDir, &nonCrit, false)) {
                        printf("horseAngle=%04x horseX=%.9g horseZ=%.9g headX=%d headZ=%d angle=%04x x=%.9g z=%.9g x_raw=%08x z_raw=%08x neighFrame=%d strainDir=%d nonCrit=%d\n",
                            horseAngle, horseX, horseZ, headX, headZ, angle, x, z, floatToInt(x), floatToInt(z), neighFrame, strainDir, nonCrit);
                        found = true;
                    }
                    return found;
                });
            }
        }
    }
}

void searchRollsWithHorsePosition(Collision* col, Vec3f horsePos, u16 horseAngle) {
    PosAngleRange range = {
        .angleMin = 0x3800,
        .angleMax = 0x5800,
        .xMin = 284,
        .xMax = 306,
        .xStep = 0.2f,
        .zMin = -920,
        .zMax = -828,
        .zStep = 0.2f,
    };

    Vec3s horseBody = generateHorseBody1(horsePos, horseAngle);
    std::vector<Vec3s> horseHeads = generateHorseHeads(horsePos, horseAngle);
    searchPosAngleRange(range, [&](u16 angle, f32 x, f32 z) {
        bool found = false;

        Vec3f pos = {x, 37, z};
        int neighFrame;
        int strainDir;
        bool nonCrit;
        if (testSetup(col, pos, angle, horseBody, horseHeads, &neighFrame, &strainDir, &nonCrit, false)) {
            printf("horseAngle=%04x horseX=%.9g horseZ=%.9g angle=%04x x=%.9g z=%.9g x_raw=%08x z_raw=%08x neighFrame=%d strainDir=%d nonCrit=%d\n",
                horseAngle, horsePos.x, horsePos.z, angle, x, z, floatToInt(x), floatToInt(z), neighFrame, strainDir, nonCrit);
            found = true;
        }
        return found;
    });
}

struct HorsePos {
    Vec3f pos;
    u16 angle;
};

std::vector<HorsePos> generateHorseSetups() {
    std::vector<HorsePos> result;
    Vec3f horsePos;

    horsePos = {intToFloat(0x438abc9f), 0, intToFloat(0xc44a82c4)};
    for (u16 horseAngle = 0x459a; horseAngle <= 0x585a; horseAngle += 0x320) {
        result.push_back({horsePos, horseAngle});
    }

    horsePos = {intToFloat(0x4395fced), 0, intToFloat(0xc443f17c)};
    for (u16 horseAngle = 0x715a; horseAngle <= 0x8d7a; horseAngle += 0x320) {
        result.push_back({horsePos, horseAngle});
    }

    horsePos = {intToFloat(0x43944a65), 0, intToFloat(0xc444670c)};
    for (u16 horseAngle = 0x67fa; horseAngle <= 0x779a; horseAngle += 0x320) {
        result.push_back({horsePos, horseAngle});
    }

    return result;
}

void searchRollsWithHorseSetups(Collision* col) {
    for (const HorsePos& horse : generateHorseSetups()) {
        fprintf(stderr, "horse: angle=%04x x=%.9g (%08x) z=%.9g (%08x)\n", horse.angle, horse.pos.x, floatToInt(horse.pos.x), horse.pos.z, floatToInt(horse.pos.z));
        searchRollsWithHorsePosition(col, horse.pos, horse.angle);
    }
}

void testCulling(Collision* col) {
    Vec3f pos = {293, 37, -839};

    Vec3f horseSpawn = {124, 0, -1343};
    CullZone horseZone = {1000, 1200, 300};
    Vec3f eponaSpawn = {0, 0, -500};
    CullZone eponaZone = {1000, 600, 300};

    for (u16 angle = 0x3000; angle <= 0x5000; angle += 16) {
        Camera camera(col);

        camera.initParallel(pos, angle, 1);
        for (int i = 0; i < 200; i++) {
            camera.updateNormal(pos, angle, 1);
        }

        f32 fovy = 60.0f;
        bool horseCull = isCulled(&camera, &horseZone, horseSpawn, fovy, 10.0f, 1280.0f);
        bool eponaCull = isCulled(&camera, &eponaZone, eponaSpawn, fovy, 10.0f, 1280.0f);
        bool bothCull = horseCull && eponaCull;
        printf("angle=%04x eye.x=%.9g eye.y=%.9g eye.z=%.9g horseCull=%d eponaCull=%d bothCull=%d\n", angle,
            camera.eye.x, camera.eye.y, camera.eye.z, horseCull, eponaCull, bothCull);
    }
}

enum EnHorseAction {
    /*  0 */ ENHORSE_ACT_FROZEN,
    /*  1 */ ENHORSE_ACT_INACTIVE,
    /*  2 */ ENHORSE_ACT_IDLE,
    /*  3 */ ENHORSE_ACT_FOLLOW_PLAYER,
    /*  4 */ ENHORSE_ACT_INGO_RACE,
    /*  5 */ ENHORSE_ACT_MOUNTED_IDLE,
    /*  6 */ ENHORSE_ACT_MOUNTED_IDLE_WHINNEYING,
    /*  7 */ ENHORSE_ACT_MOUNTED_TURN,
    /*  8 */ ENHORSE_ACT_MOUNTED_WALK,
    /*  9 */ ENHORSE_ACT_MOUNTED_TROT,
    /* 10 */ ENHORSE_ACT_MOUNTED_GALLOP,
    /* 11 */ ENHORSE_ACT_MOUNTED_REARING,
    /* 12 */ ENHORSE_ACT_STOPPING,
    /* 13 */ ENHORSE_ACT_REVERSE,
    /* 14 */ ENHORSE_ACT_LOW_JUMP,
    /* 15 */ ENHORSE_ACT_HIGH_JUMP,
    /* 16 */ ENHORSE_ACT_BRIDGE_JUMP,
    /* 17 */ ENHORSE_ACT_CS_UPDATE,
    /* 18 */ ENHORSE_ACT_HBA,
    /* 19 */ ENHORSE_ACT_FLEE_PLAYER
};

struct EnHorse {
    EnHorseAction action = ENHORSE_ACT_MOUNTED_IDLE;
    Vec3f pos;
    u16 angle;
    f32 speed = 0.0f;
    f32 animEndFrame = 0.0f;
    f32 animCurFrame = 0.0f;
    f32 animPlaySpeed = 1.0f;

    EnHorse(Vec3f pos, u16 angle) : pos(pos), angle(angle) {}

    void setupAction(EnHorseAction action, f32 animEndFrame) {
        this->action = action;
        this->animEndFrame = animEndFrame;
        this->animCurFrame = 0.0f;
        this->animPlaySpeed = 1.0f;
    }

    bool updateAnim() {
        if (this->animCurFrame == this->animEndFrame) {
            return true;
        }

        this->animCurFrame += this->animPlaySpeed;
        if (this->animCurFrame >= this->animEndFrame) {
            this->animCurFrame = this->animEndFrame;
        }
        return false;
    }

    void updateSpeed(bool holdUp, f32 brakeDecel, f32 decel, f32 baseSpeed) {
        // TODO: EnHorse_SlopeSpeedMultiplier
        if (!holdUp) {
            this->speed -= decel;
            if (this->speed < 0.0f) {
                this->speed = 0.0f;
            }
        } else {
            f32 stickMag = 60.0f;
            this->speed += (this->speed <= baseSpeed * (1.0f / 54.0f) * stickMag ? 1.0f : -1.0f) * 50.0f * 0.01f;
            if (baseSpeed < this->speed) {
                this->speed -= decel;
                if (this->speed < baseSpeed) {
                    this->speed = baseSpeed;
                }
            }
        }
    }

    bool update(Collision* col, bool holdUp) {
        switch (this->action) {
            case ENHORSE_ACT_MOUNTED_IDLE:
                this->speed = 0.0f;
                if (holdUp) {
                    // TODO: Should wait for 8 frames
                    this->setupAction(ENHORSE_ACT_MOUNTED_WALK, 34.0f);
                }
                break;
            case ENHORSE_ACT_MOUNTED_WALK:
                this->updateSpeed(holdUp, 0.3f, 0.06f, 3.0f);
                if (this->speed == 0.0f) {
                    this->setupAction(ENHORSE_ACT_MOUNTED_IDLE, 0.0f);
                } else if (this->speed > 3.0f) {
                    this->setupAction(ENHORSE_ACT_MOUNTED_TROT, 28.0f);
                }
                this->animPlaySpeed = this->speed * 0.75f;
                if (this->updateAnim()) {
                    if (this->speed > 3.0f) {
                        this->setupAction(ENHORSE_ACT_MOUNTED_TROT, 28.0f);
                    } else if (!holdUp) {
                        this->setupAction(ENHORSE_ACT_MOUNTED_IDLE, 0.0f);
                    } else {
                        this->setupAction(ENHORSE_ACT_MOUNTED_WALK, 34.0f);
                    }
                }
                break;
            case ENHORSE_ACT_MOUNTED_TROT:
                this->updateSpeed(holdUp, 0.3f, 0.06f, 6.0f);
                if (this->speed < 3.0f) {
                    this->setupAction(ENHORSE_ACT_MOUNTED_WALK, 34.0f);
                }

                this->animPlaySpeed = this->speed * 0.375f;
                if (this->updateAnim()) {
                    if (this->speed >= 6.0f) {
                        this->setupAction(ENHORSE_ACT_MOUNTED_GALLOP, 23.0f);
                    } else {
                        this->setupAction(ENHORSE_ACT_MOUNTED_TROT, 28.0f);
                    }
                }
                break;
            case ENHORSE_ACT_MOUNTED_GALLOP:
                this->updateSpeed(holdUp, 0.3f, 0.06f, 8.0f);
                if (this->speed < 6.0f) {
                    this->setupAction(ENHORSE_ACT_MOUNTED_TROT, 28.0f);
                }

                this->animPlaySpeed = this->speed * 0.3f;
                if (this->updateAnim()) {
                    // TODO: braking?
                    if (this->speed < 6.0f) {
                        this->setupAction(ENHORSE_ACT_MOUNTED_TROT, 28.0f);
                    } else {
                        this->setupAction(ENHORSE_ACT_MOUNTED_GALLOP, 23.0f);
                    }
                }
                break;
            default:
                return false;
        }

        CollisionPoly* wallPoly;
        CollisionPoly* floorPoly;
        int dynaId;
        f32 floorHeight;
        this->pos = col->runChecks(this->pos, translate(this->pos, this->angle, this->speed, -7.5f), 19.0f, 35.0f,
            &wallPoly, &floorPoly, &dynaId, &floorHeight);

        if (wallPoly != nullptr) {
            Vec3f normal = CollisionPoly_GetNormalF(wallPoly);
            u16 wallYaw = Math_Atan2S(normal.z, normal.x);
            if (Math_CosS(wallYaw - this->angle) < -0.3f && this->speed > 4.0f) {
                this->speed -= 1.0f;
            }
        }

        return true;
    }
};

void testHorse(Collision* col) {
    EnHorse horse({intToFloat(0xc394843e), 0, intToFloat(0xc4a0ecd4)}, 0x297a);

    for (int i = 9; i < 200; i++) {
        bool holdUp = i <= 35;
        if (!horse.update(col, holdUp)) {
            break;
        }
        if (i > 10 && horse.speed == 0.0f) {
            break;
        }
        printf("frame %d: holdUp=%d x=%.9g y=%.9g z=%.9g action=%d speed=%.2f animEndFrame=%.0f animCurFrame=%.3f animPlaySpeed=%.3f\n",
            i, holdUp, horse.pos.x, horse.pos.y, horse.pos.z, horse.action, horse.speed, horse.animEndFrame, horse.animCurFrame, horse.animPlaySpeed);
    }
}

void testHorseWalks(Collision* col) {
    for (u16 angle = 0x265a - 0x320; angle <= 0x265a; angle += 0x320) {
        for (int holdUpFrames = 20; holdUpFrames <= 55; holdUpFrames++) {
            EnHorse horse({intToFloat(0xc394843e), 0, intToFloat(0xc4a0ecd4)}, angle);
            for (int i = 9; i < 200; i++) {
                bool holdUp = i <= holdUpFrames;
                if (!horse.update(col, holdUp)) {
                    break;
                }
                if (i > 10 && horse.speed == 0.0f) {
                    break;
                }
            }
            printf("angle=%04x holdUpFrames=%d x=%.9g (%08x) z=%.9g (%08x)\n",
                angle, holdUpFrames, horse.pos.x, floatToInt(horse.pos.x), horse.pos.z, floatToInt(horse.pos.z));
        }
    }
}

Vec3f getRidePosition(Vec3f pos, u16 angle) {
    int limbCount = ARRAY_COUNT(gHorseIngoSkel);
    Vec3s jointTable[limbCount];
    MtxF mtx;
    MtxF limbMatrices[limbCount];
    Vec3f rootPos;

    loadAnimFrame(&gHorseIngoIdleAnim, limbCount, 10, &rootPos, jointTable);
    applySkinSkeleton(gHorseIngoSkel, limbCount, jointTable, pos, angle, rootPos, &mtx, limbMatrices);

    Vec3f riderOffset = { 600.0f, -1670.0f, 0.0f };
    Vec3f ridePos;
    MtxF mtxf;
    SkinMatrix_MtxFMtxFMult(&mtx, &limbMatrices[30], &mtxf);
    SkinMatrix_Vec3fMtxFMultXYZ(&mtxf, &riderOffset, &ridePos);
    ridePos = ridePos - pos;
    ridePos = ridePos + pos;
    ridePos.y -= 27.0f;

    AnimFrame animFrame;
    Vec3f prevRootPos;
    Vec3f tempPos;

    // Set prevRootPos from previous riding animation (not sure what it actually is but this works)
    loadAnimFrame(gPlayerAnim_link_uma_anim_walk2_Data, 0, &animFrame);
    updateRootTranslation(&animFrame, &tempPos, angle, &prevRootPos);

    // Apply translation with current riding animation
    loadAnimFrame(gPlayerAnim_link_uma_wait_3_Data, 0, &animFrame);
    updateRootTranslation(&animFrame, &ridePos, angle, &prevRootPos);

    return ridePos;
}

struct HorseSetup {
    u16 angle;
    f32 horseX;
    f32 horseZ;
    f32 linkX;
    f32 linkZ;
};

std::vector<HorseSetup> horseSetups = {
    // turn to 0x265a
    // 31 frames up
    // { 0x459a, intToFloat(0x438abc9f), intToFloat(0xc44a82c4), intToFloat(0x438ebc19), intToFloat(0xc442286c) },
    // { 0x48ba, intToFloat(0x438abc9f), intToFloat(0xc44a82c4), intToFloat(0x43900125), intToFloat(0xc44255fa) },
    // { 0x4bda, intToFloat(0x438abc9f), intToFloat(0xc44a82c4), intToFloat(0x43913e3f), intToFloat(0xc4428fe3) },
    { 0x4efa, intToFloat(0x438abc9f), intToFloat(0xc44a82c4), intToFloat(0x43927171), intToFloat(0xc442d5b8) },
    { 0x521a, intToFloat(0x438abc9f), intToFloat(0xc44a82c4), intToFloat(0x43939908), intToFloat(0xc443272c) },
    { 0x553a, intToFloat(0x438abc9f), intToFloat(0xc44a82c4), intToFloat(0x4394b361), intToFloat(0xc44383b6) },
    { 0x585a, intToFloat(0x438abc9f), intToFloat(0xc44a82c4), intToFloat(0x4395be8f), intToFloat(0xc443ead2) },
    // 35, 37, 39, 47, 49 frames up
    { 0x715a, intToFloat(0x4395fced), intToFloat(0xc443f17c), intToFloat(0x43a69566), intToFloat(0xc441ba0e) },
    { 0x747a, intToFloat(0x4395fced), intToFloat(0xc443f17c), intToFloat(0x43a6dfe2), intToFloat(0xc4425eae) },
    { 0x779a, intToFloat(0x4395fced), intToFloat(0xc443f17c), intToFloat(0x43a710f4), intToFloat(0xc443059d) },
    // { 0x7aba, intToFloat(0x4395fced), intToFloat(0xc443f17c), intToFloat(0x43a72847), intToFloat(0xc443adfe) },
    // { 0x7dda, intToFloat(0x4395fced), intToFloat(0xc443f17c), intToFloat(0x43a725bf), intToFloat(0xc44456c9) },
    // { 0x80fa, intToFloat(0x4395fced), intToFloat(0xc443f17c), intToFloat(0x43a70a19), intToFloat(0xc444fb7f) },
    // { 0x841a, intToFloat(0x4395fced), intToFloat(0xc443f17c), intToFloat(0x43a6d45d), intToFloat(0xc445a218) },
    // { 0x873a, intToFloat(0x4395fced), intToFloat(0xc443f17c), intToFloat(0x43a6855a), intToFloat(0xc446462a) },
    // { 0x8a5a, intToFloat(0x4395fced), intToFloat(0xc443f17c), intToFloat(0x43a61d42), intToFloat(0xc446e6c2) },
    // { 0x8d7a, intToFloat(0x4395fced), intToFloat(0xc443f17c), intToFloat(0x43a59d03), intToFloat(0xc44782cf) },
    // 41, 43, 45 frames up
    // { 0x67fa, intToFloat(0x43944a65), intToFloat(0xc444670c), intToFloat(0x43a36fa2), intToFloat(0xc440599c) },
    { 0x6b1a, intToFloat(0x43944a65), intToFloat(0xc444670c), intToFloat(0x43a4034d), intToFloat(0xc440f165) },
    { 0x6e3a, intToFloat(0x43944a65), intToFloat(0xc444670c), intToFloat(0x43a47f51), intToFloat(0xc4418e57) },
    { 0x715a, intToFloat(0x43944a65), intToFloat(0xc444670c), intToFloat(0x43a4e2de), intToFloat(0xc4422f9e) },
    { 0x747a, intToFloat(0x43944a65), intToFloat(0xc444670c), intToFloat(0x43a52d5a), intToFloat(0xc442d43e) },
    // { 0x779a, intToFloat(0x43944a65), intToFloat(0xc444670c), intToFloat(0x43a55e6c), intToFloat(0xc4437b2d) },
};

void findSetups(Collision* col, const HorseSetup& horseSetup) {
    u16 horseAngle = horseSetup.angle;
    Vec3f horsePos = {horseSetup.horseX, 0, horseSetup.horseZ};
    Vec3f linkPos = {horseSetup.linkX, 0, horseSetup.linkZ};

    Vec3s horseBody1 = generateHorseBody1(horsePos, horseAngle);
    Vec3s horseBody2 = generateHorseBody2(horsePos, horseAngle);
    std::vector<Vec3s> horseHeads = generateHorseHeads(horsePos, horseAngle);

    SearchParams params = {
        .col = col,
        .minBounds = {-10000, 0, -10000},
        .maxBounds = {10000, 10000, 10000},
        .colliders = {
            {horseBody1, 20, 1.0f},
            {horseBody2, 20, 1.0f},
        },
        .starts =
            {
                {linkPos, horseAngle},
                {linkPos, horseAngle + 0x4000},
            },
        .maxCost = 100,
        .angleMin = 0x3800,
        .angleMax = 0x5800,
        .xMin = 284,
        .xMax = 306,
        .zMin = -920,
        .zMax = -828,
        .actions =
            {
                TARGET_WALL,
                ROLL,
                BACKFLIP,
                BACKFLIP_SIDEROLL,
                BACKFLIP_SIDEROLL_UNTARGET,
                SIDEHOP_LEFT,
                SIDEHOP_LEFT_SIDEROLL,
                SIDEHOP_LEFT_SIDEROLL_UNTARGET,
                SIDEHOP_RIGHT,
                SIDEHOP_RIGHT_SIDEROLL,
                SIDEHOP_RIGHT_SIDEROLL_UNTARGET,
                ROTATE_ESS_LEFT,
                ROTATE_ESS_RIGHT,
                ESS_TURN_UP,
                ESS_TURN_LEFT,
                ESS_TURN_RIGHT,
                ESS_TURN_DOWN,
            },
    };
    
    auto filter = [&](Vec3f initialPos, u16 initialAngle,
                    const PosAngleSetup& setup, const std::vector<Action>& path,
                    int cost) {
    Vec3f pos = setup.pos;
    Vec3f horseHead = Vec3f(horseHeads[27]);
    if (Math_Vec3f_DistXZ(&pos, &horseHead) < 40.0f) {
        return false;
    }

    return true;
  };

    auto output = [=](Vec3f initialPos, u16 initialAngle,
                        const PosAngleSetup& setup,
                        const std::vector<Action>& actions, int cost) {
        bool found = false;
        Vec3f pos = setup.pos;
        u16 angle = setup.angle;
        int neighFrame;
        int strainDir;
        bool nonCrit;
        if (testSetup(col, pos, angle, horseBody1, horseHeads, &neighFrame, &strainDir, &nonCrit, false)) {
            if (nonCrit) {
                printf(
                    "cost=%d horseX=%.9g (%08x) horseZ=%.9g (%08x) horseAngle=%04x "
                    "initialX=%.9g (%08x) initialZ=%.9g (%08x) initialAngle=%04x "
                    "x=%.9g (%08x) z=%.9g (%08x) angle=%04x neighFrame=%d strainDir=%d nonCrit=%d actions=%s\n",
                    cost, horseSetup.horseX, floatToInt(horseSetup.horseX), horseSetup.horseZ, floatToInt(horseSetup.horseZ), horseAngle,
                    initialPos.x, floatToInt(initialPos.x), initialPos.z, floatToInt(initialPos.z), initialAngle,
                    pos.x, floatToInt(pos.x), pos.z, floatToInt(pos.z), angle, neighFrame, strainDir, nonCrit,
                    actionNames(actions).c_str());
                fflush(stdout);
                found = true;
            }
        }

        return found;
    };

    searchSetups(params, filter, output);
}

int main(int argc, char* argv[]) {
    Collision col(&spot20_sceneCollisionHeader_002948, PLAYER_AGE_ADULT);
    col.addDynapoly(&gJumpableHorseFenceCol, {0.1f, 0.1f, 0.1f}, {0, 0x4000, 0}, {295, -27, -989});
    col.addPoly(1);
    col.addPoly(13);
    col.addPoly(15);
    // col.printPolys();

    // Vec3f horsePos = {intToFloat(0x437a85b0), 0, intToFloat(0xc44a1b56)};
    // u16 horseAngle = 0x48b1;
    // Vec3f linkPos = {intToFloat(0x43954000), 37, intToFloat(0xc45ed814)};
    // u16 linkAngle = 0xf93e;
    // Vec3s horseBody = generateHorseBody1(horsePos, horseAngle);
    // std::vector<Vec3s> horseHeads = generateHorseHeads(horsePos, horseAngle);
    // int neighFrame;
    // int strainDir;
    // simulateRoll(linkPos, linkAngle, horseBody, horseHeads, &neighFrame, &strainDir, true);

    // Vec3f horsePos = {intToFloat(0x438abc9f), 0, intToFloat(0xc44a82c4)};
    // u16 horseAngle = 0x553a;
    // Vec3f linkPos = {intToFloat(0x4393fdd8), 37, intToFloat(0xc461fbb6)};
    // u16 linkAngle = 0x472a;
    // Vec3s horseBody = generateHorseBody1(horsePos, horseAngle);
    // std::vector<Vec3s> horseHeads = generateHorseHeads(horsePos, horseAngle);
    // int neighFrame;
    // int strainDir;
    // bool nonCrit;
    // testSetup(&col, linkPos, linkAngle, horseBody, horseHeads, &neighFrame, &strainDir, &nonCrit, true);

    // searchRolls(&col);

    // testCulling(&col);

    // testHorse(&col);
    // testHorseWalks(&col);

    // searchRollsWithHorseSetups(&col);

    if (argc > 1) {
        int index = strtoul(argv[1], NULL, 0);
        findSetups(&col, horseSetups[index]);
    }

    return 0;
}
